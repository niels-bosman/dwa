{"ast":null,"code":"import _defineProperty from \"/home/niels/Projects/school/niels-bosman/client/6/6-1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";\nimport _objectSpread from \"/home/niels/Projects/school/niels-bosman/client/6/6-1/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread\";\nimport * as Redux from 'redux'; // dummy data, needed because this version does not do AJAX yet.\n\nimport initialFrontPageData from './frontPageData';\nimport initialItemStatuses from './itemStatuses'; //=====================================================================\n//    State management for HN Items and their read/seen-statuses\n//---------------------------------------------------------------------\n// Action Creators:\n\nexport function markAsSeenAction(listSize) {\n  return {\n    type: 'markAsSeenAction',\n    listSize: listSize\n  };\n}\nexport function toggleItemAction(item) {\n  return {\n    type: 'toggleItemAction',\n    item: item\n  };\n} // Reducer:\n\nvar initialHNItemsState = {\n  items: initialFrontPageData,\n  selectedItem: null,\n  statuses: initialItemStatuses\n};\n\nfunction hnItemsReducer() {\n  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialHNItemsState;\n  var action = arguments.length > 1 ? arguments[1] : undefined;\n\n  // Note how all branches of the switch-statement always return\n  // (a new version of) the state. Reducers must always return a (new) state.\n  switch (action.type) {\n    case 'toggleItemAction':\n      if (state.selectedItem) {\n        if (action.item.id === state.selectedItem.id) {\n          return _objectSpread({}, state, {\n            selectedItem: null\n          });\n        }\n      }\n\n      var newStatuses = _objectSpread({}, state.statuses, _defineProperty({}, action.item.id, 'read'));\n\n      return _objectSpread({}, state, {\n        selectedItem: action.item,\n        statuses: newStatuses\n      });\n    // break; not needed: this branch always returns from function\n\n    case 'markAsSeenAction':\n      newStatuses = _objectSpread({}, state.statuses);\n      state.items.forEach(function (itm, idx) {\n        if (idx < action.listSize && state.statuses[itm.id] === undefined) {\n          newStatuses[itm.id] = 'seen';\n        }\n      });\n      return _objectSpread({}, state, {\n        statuses: newStatuses\n      });\n    // break; not needed: this branch always returns from function\n\n    default:\n      return state;\n  }\n} // ==============================================================\n//\n// using immer.js\n//\n// function hnItemsReducer(state = initialHNItemsState, action) {\n//   const reducers = {\n//     toggleItemAction: (draft, action) => {\n//       if (\n//         draft.item &&\n//         draft.selectedItem &&\n//         draft.item.id === draft.selectedItem.id\n//       ) {\n//         draft.selectedItem = null;\n//       } else {\n//         draft.statuses[action.item.id] = \"read\";\n//         draft.selectedItem = action.item;\n//       }\n//     },\n//     markAsSeenAction: (draft, action) => {\n//       draft.items.forEach((itm, idx) => {\n//         if (idx < action.listSize && draft.statuses[itm.id] === undefined) {\n//           draft.statuses[itm.id] = \"seen\";\n//         }\n//       });\n//     },\n//   };\n//   return produce(state, (draft) =>\n//     reducers[action.type] ? reducers[action.type](draft, action) : draft\n//   );\n// }\n//=====================================================================\n//    State management for the Preferences\n//---------------------------------------------------------------------\n// Action Creators:\n\n\nexport function showPrefsAction() {\n  return {\n    type: 'showPrefsAction'\n  };\n}\nexport function doEditListSizeAction(listSize) {\n  return {\n    type: 'editListSizeAction',\n    payload: listSize\n  };\n}\nexport function doEditColorAction(color) {\n  return {\n    type: 'editColorAction',\n    payload: color\n  };\n}\nexport function doCloseAndApplyPrefsAction() {\n  return {\n    type: 'closeAndApplyPrefsAction'\n  };\n}\nexport function doCancelPrefsAction() {\n  return {\n    type: 'cancelPrefsAction'\n  };\n}\nvar initialPreferencesState = {\n  showingPrefs: false,\n  editingColor: null,\n  editingListSize: 42,\n  currentColor: 'orange',\n  currentListSize: 42\n};\n\nfunction preferencesReducer() {\n  var state = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : initialPreferencesState;\n  var action = arguments.length > 1 ? arguments[1] : undefined;\n\n  // Note how all branches of the switch-statement always return\n  // (a new version of) the state. Reducers must always return a (new) state.\n  switch (action.type) {\n    case 'showPrefsAction':\n      var changes = {\n        showingPrefs: true,\n        editingColor: state.currentColor,\n        editingListSize: state.currentListSize\n      };\n      return _objectSpread({}, state, changes);\n\n    case 'editListSizeAction':\n      return _objectSpread({}, state, {\n        editingListSize: action.payload\n      });\n\n    case 'editColorAction':\n      return _objectSpread({}, state, {\n        editingColor: action.payload\n      });\n\n    case 'closeAndApplyPrefsAction':\n      return _objectSpread({}, state, {\n        currentColor: state.editingColor,\n        currentListSize: state.editingListSize,\n        showingPrefs: false\n      });\n\n    case 'cancelPrefsAction':\n      return _objectSpread({}, state, {\n        showingPrefs: false\n      });\n\n    default:\n      return state;\n  }\n} //===========================================================================\n//  Combining the reducers and their state into a single reducer managing\n//  a single state\n//---------------------------------------------------------------------------\n\n\nexport var mainReducer = Redux.combineReducers({\n  hnItems: hnItemsReducer,\n  prefs: preferencesReducer\n});","map":{"version":3,"sources":["/home/niels/Projects/school/niels-bosman/client/6/6-1/src/reducers.js"],"names":["Redux","initialFrontPageData","initialItemStatuses","markAsSeenAction","listSize","type","toggleItemAction","item","initialHNItemsState","items","selectedItem","statuses","hnItemsReducer","state","action","id","newStatuses","forEach","itm","idx","undefined","showPrefsAction","doEditListSizeAction","payload","doEditColorAction","color","doCloseAndApplyPrefsAction","doCancelPrefsAction","initialPreferencesState","showingPrefs","editingColor","editingListSize","currentColor","currentListSize","preferencesReducer","changes","mainReducer","combineReducers","hnItems","prefs"],"mappings":"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","sourcesContent":["import * as Redux from 'redux';\n\n// dummy data, needed because this version does not do AJAX yet.\nimport initialFrontPageData from './frontPageData';\nimport initialItemStatuses from './itemStatuses';\n\n//=====================================================================\n//    State management for HN Items and their read/seen-statuses\n//---------------------------------------------------------------------\n\n// Action Creators:\n\nexport function markAsSeenAction(listSize) {\n  return { type: 'markAsSeenAction', listSize };\n}\n\nexport function toggleItemAction(item) {\n  return { type: 'toggleItemAction', item };\n}\n\n// Reducer:\n\nconst initialHNItemsState = {\n  items:        initialFrontPageData,\n  selectedItem: null,\n  statuses:     initialItemStatuses,\n};\n\nfunction hnItemsReducer(state = initialHNItemsState, action) {\n  // Note how all branches of the switch-statement always return\n  // (a new version of) the state. Reducers must always return a (new) state.\n  switch (action.type) {\n    case 'toggleItemAction':\n      if (state.selectedItem) {\n        if (action.item.id === state.selectedItem.id) {\n          return { ...state, selectedItem: null };\n        }\n      }\n      let newStatuses = { ...state.statuses, [action.item.id]: 'read' };\n      return { ...state, selectedItem: action.item, statuses: newStatuses };\n    // break; not needed: this branch always returns from function\n\n    case 'markAsSeenAction':\n      newStatuses = { ...state.statuses };\n      state.items.forEach((itm, idx) => {\n        if (idx < action.listSize && state.statuses[itm.id] === undefined) {\n          newStatuses[itm.id] = 'seen';\n        }\n      });\n      return { ...state, statuses: newStatuses };\n    // break; not needed: this branch always returns from function\n\n    default:\n      return state;\n  }\n}\n\n// ==============================================================\n//\n// using immer.js\n//\n\n// function hnItemsReducer(state = initialHNItemsState, action) {\n//   const reducers = {\n//     toggleItemAction: (draft, action) => {\n//       if (\n//         draft.item &&\n//         draft.selectedItem &&\n//         draft.item.id === draft.selectedItem.id\n//       ) {\n//         draft.selectedItem = null;\n//       } else {\n//         draft.statuses[action.item.id] = \"read\";\n//         draft.selectedItem = action.item;\n//       }\n//     },\n\n//     markAsSeenAction: (draft, action) => {\n//       draft.items.forEach((itm, idx) => {\n//         if (idx < action.listSize && draft.statuses[itm.id] === undefined) {\n//           draft.statuses[itm.id] = \"seen\";\n//         }\n//       });\n//     },\n//   };\n\n//   return produce(state, (draft) =>\n//     reducers[action.type] ? reducers[action.type](draft, action) : draft\n//   );\n// }\n\n//=====================================================================\n//    State management for the Preferences\n//---------------------------------------------------------------------\n\n// Action Creators:\n\nexport function showPrefsAction() {\n  return { type: 'showPrefsAction' };\n}\n\nexport function doEditListSizeAction(listSize) {\n  return { type: 'editListSizeAction', payload: listSize };\n}\n\nexport function doEditColorAction(color) {\n  return { type: 'editColorAction', payload: color };\n}\n\nexport function doCloseAndApplyPrefsAction() {\n  return { type: 'closeAndApplyPrefsAction' };\n}\n\nexport function doCancelPrefsAction() {\n  return { type: 'cancelPrefsAction' };\n}\n\nconst initialPreferencesState = {\n  showingPrefs:    false,\n  editingColor:    null,\n  editingListSize: 42,\n  currentColor:    'orange',\n  currentListSize: 42,\n};\n\nfunction preferencesReducer(state = initialPreferencesState, action) {\n  // Note how all branches of the switch-statement always return\n  // (a new version of) the state. Reducers must always return a (new) state.\n  switch (action.type) {\n    case 'showPrefsAction':\n      let changes = {\n        showingPrefs:    true,\n        editingColor:    state.currentColor,\n        editingListSize: state.currentListSize,\n      };\n      return { ...state, ...changes };\n\n    case 'editListSizeAction':\n      return { ...state, ...{ editingListSize: action.payload } };\n\n    case 'editColorAction':\n      return { ...state, ...{ editingColor: action.payload } };\n\n    case 'closeAndApplyPrefsAction':\n      return {\n        ...state, ...{\n          currentColor:    state.editingColor,\n          currentListSize: state.editingListSize,\n          showingPrefs:    false\n        }\n      };\n\n    case 'cancelPrefsAction':\n      return { ...state, showingPrefs: false };\n    default:\n      return state;\n  }\n}\n\n//===========================================================================\n//  Combining the reducers and their state into a single reducer managing\n//  a single state\n//---------------------------------------------------------------------------\n\nexport const mainReducer = Redux.combineReducers({\n  hnItems: hnItemsReducer,\n  prefs:   preferencesReducer,\n});\n"]},"metadata":{},"sourceType":"module"}